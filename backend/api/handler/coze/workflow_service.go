/*
 * Copyright 2025 coze-dev Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Code generated by hertz generator.

package coze

import (
	"context"
	"errors"
	"fmt"
	"io"

	"github.com/cloudwego/eino/schema"
	"github.com/cloudwego/hertz/pkg/app"
	"github.com/cloudwego/hertz/pkg/protocol/consts"
	"github.com/cloudwego/hertz/pkg/protocol/sse"

	"github.com/coze-dev/coze-studio/backend/api/model/ocean/cloud/workflow"
	appworkflow "github.com/coze-dev/coze-studio/backend/application/workflow"
	"github.com/coze-dev/coze-studio/backend/domain/workflow/entity/vo"
	"github.com/coze-dev/coze-studio/backend/pkg/lang/ptr"
	"github.com/coze-dev/coze-studio/backend/pkg/logs"
	"github.com/coze-dev/coze-studio/backend/pkg/sonic"
)

// CreateWorkflow 创建工作流API处理函数
// 该函数负责处理创建工作流的HTTP POST请求，包括参数验证、业务逻辑调用和响应返回
// @router /api/workflow_api/create [POST]
func CreateWorkflow(ctx context.Context, c *app.RequestContext) {
	var err error
	// 定义请求参数结构体，用于接收客户端传来的工作流创建请求数据
	var req workflow.CreateWorkflowRequest

	// 将HTTP请求体中的JSON数据绑定到请求结构体，并进行参数验证
	// 如果请求格式不正确或必填字段缺失，会返回验证错误
	err = c.BindAndValidate(&req)
	if err != nil {
		// 参数绑定或验证失败，返回400 Bad Request错误响应给客户端
		invalidParamRequestResponse(c, err.Error())
		return
	}

	// 调用应用层服务执行工作流创建的核心业务逻辑
	// 传入上下文和验证后的请求参数
	resp, err := appworkflow.SVC.CreateWorkflow(ctx, &req)
	if err != nil {
		// 业务逻辑处理失败（如数据库操作失败、业务规则校验失败等）
		// 返回500 Internal Server Error错误响应
		internalServerErrorResponse(ctx, c, err)
		return
	}

	// 工作流创建成功，返回200 OK状态码和创建结果的JSON响应
	// resp包含新创建的工作流信息
	c.JSON(consts.StatusOK, resp)
}

// GetCanvasInfo .
// @router /api/workflow_api/canvas [POST]
func GetCanvasInfo(ctx context.Context, c *app.RequestContext) {
	var err error
	var req workflow.GetCanvasInfoRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		invalidParamRequestResponse(c, err.Error())
		return
	}

	resp, err := appworkflow.SVC.GetCanvasInfo(ctx, &req)
	if err != nil {
		internalServerErrorResponse(ctx, c, err)
		return
	}

	c.JSON(consts.StatusOK, resp)
}

// SaveWorkflow .
// @router /api/workflow_api/save [POST]
func SaveWorkflow(ctx context.Context, c *app.RequestContext) {
	var err error
	var req workflow.SaveWorkflowRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		invalidParamRequestResponse(c, err.Error())
		return
	}

	resp, err := appworkflow.SVC.SaveWorkflow(ctx, &req)
	if err != nil {
		internalServerErrorResponse(ctx, c, err)
		return
	}

	c.JSON(consts.StatusOK, resp)
}

// UpdateWorkflowMeta .
// @router /api/workflow_api/update_meta [POST]
func UpdateWorkflowMeta(ctx context.Context, c *app.RequestContext) {
	var err error
	var req workflow.UpdateWorkflowMetaRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		invalidParamRequestResponse(c, err.Error())
		return
	}
	resp, err := appworkflow.SVC.UpdateWorkflowMeta(ctx, &req)

	if err != nil {
		internalServerErrorResponse(ctx, c, err)
		return
	}

	c.JSON(consts.StatusOK, resp)
}

// DeleteWorkflow .
// @router /api/workflow_api/delete [POST]
func DeleteWorkflow(ctx context.Context, c *app.RequestContext) {
	var err error
	var req workflow.DeleteWorkflowRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		invalidParamRequestResponse(c, err.Error())
		return
	}

	resp, err := appworkflow.SVC.DeleteWorkflow(ctx, &req)
	if err != nil {
		internalServerErrorResponse(ctx, c, err)
		return
	}

	c.JSON(consts.StatusOK, resp)
}

// BatchDeleteWorkflow .
// @router /api/workflow_api/batch_delete [POST]
func BatchDeleteWorkflow(ctx context.Context, c *app.RequestContext) {
	var err error
	var req workflow.BatchDeleteWorkflowRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		invalidParamRequestResponse(c, err.Error())
		return
	}

	resp, err := appworkflow.SVC.BatchDeleteWorkflow(ctx, &req)
	if err != nil {
		invalidParamRequestResponse(c, err.Error())
		return
	}

	c.JSON(consts.StatusOK, resp)
}

// GetDeleteStrategy .
// @router /api/workflow_api/delete_strategy [POST]
func GetDeleteStrategy(ctx context.Context, c *app.RequestContext) {
	var err error
	var req workflow.GetDeleteStrategyRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		invalidParamRequestResponse(c, err.Error())
		return
	}

	resp := new(workflow.GetDeleteStrategyResponse)

	c.JSON(consts.StatusOK, resp)
}

// PublishWorkflow .
// @router /api/workflow_api/publish [POST]
func PublishWorkflow(ctx context.Context, c *app.RequestContext) {
	var err error
	var req workflow.PublishWorkflowRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		invalidParamRequestResponse(c, err.Error())
		return
	}
	resp, err := appworkflow.SVC.PublishWorkflow(ctx, &req)
	if err != nil {
		internalServerErrorResponse(ctx, c, err)
		return
	}

	c.JSON(consts.StatusOK, resp)
}

// CopyWorkflow .
// @router /api/workflow_api/copy [POST]
func CopyWorkflow(ctx context.Context, c *app.RequestContext) {
	var err error
	var req workflow.CopyWorkflowRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		invalidParamRequestResponse(c, err.Error())
		return
	}
	resp, err := appworkflow.SVC.CopyWorkflow(ctx, &req)
	if err != nil {
		internalServerErrorResponse(ctx, c, err)
		return
	}

	c.JSON(consts.StatusOK, resp)
}

// CopyWkTemplateApi .
// @router /api/workflow_api/copy_wk_template [POST]
func CopyWkTemplateApi(ctx context.Context, c *app.RequestContext) {
	var err error
	var req workflow.CopyWkTemplateApiRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		invalidParamRequestResponse(c, err.Error())
		return
	}
	resp, err := appworkflow.SVC.CopyWkTemplateApi(ctx, &req)
	if err != nil {
		internalServerErrorResponse(ctx, c, err)
		return
	}
	c.JSON(consts.StatusOK, resp)
}

// GetReleasedWorkflows .
// @router /api/workflow_api/released_workflows [POST]
func GetReleasedWorkflows(ctx context.Context, c *app.RequestContext) {
	var err error
	var req workflow.GetReleasedWorkflowsRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		invalidParamRequestResponse(c, err.Error())
		return
	}

	resp := new(workflow.GetReleasedWorkflowsResponse)

	c.JSON(consts.StatusOK, resp)
}

// GetWorkflowReferences
// @router /api/workflow_api/workflow_references [POST]
func GetWorkflowReferences(ctx context.Context, c *app.RequestContext) {
	var err error
	var req workflow.GetWorkflowReferencesRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		invalidParamRequestResponse(c, err.Error())
		return
	}
	resp, err := appworkflow.SVC.GetWorkflowReferences(ctx, &req)
	if err != nil {
		internalServerErrorResponse(ctx, c, err)
		return
	}

	c.JSON(consts.StatusOK, resp)
}

// GetWorkFlowList .
// @router /api/workflow_api/workflow_list [POST]
func GetWorkFlowList(ctx context.Context, c *app.RequestContext) {
	var err error
	var req workflow.GetWorkFlowListRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		invalidParamRequestResponse(c, err.Error())
		return
	}
	resp, err := appworkflow.SVC.ListWorkflow(ctx, &req)
	if err != nil {
		internalServerErrorResponse(ctx, c, err)
		return
	}

	c.JSON(consts.StatusOK, resp)
}

// QueryWorkflowNodeTypes .
// @router /api/workflow_api/node_type [POST]
func QueryWorkflowNodeTypes(ctx context.Context, c *app.RequestContext) {
	var err error
	var req workflow.QueryWorkflowNodeTypeRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		invalidParamRequestResponse(c, err.Error())
		return
	}
	resp, err := appworkflow.SVC.QueryWorkflowNodeTypes(ctx, &req)
	if err != nil {
		c.String(consts.StatusInternalServerError, err.Error())
		return
	}

	c.JSON(consts.StatusOK, resp)
}

// NodeTemplateList .
// @router /api/workflow_api/node_template_list [POST]
func NodeTemplateList(ctx context.Context, c *app.RequestContext) {
	var err error
	var req workflow.NodeTemplateListRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		invalidParamRequestResponse(c, err.Error())
		return
	}

	resp, err := appworkflow.SVC.GetNodeTemplateList(ctx, &req)
	if err != nil {
		internalServerErrorResponse(ctx, c, err)
		return
	}

	c.JSON(consts.StatusOK, resp)
}

// NodePanelSearch .
// @router /api/workflow_api/node_panel_search [POST]
func NodePanelSearch(ctx context.Context, c *app.RequestContext) {
	var err error
	var req workflow.NodePanelSearchRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		invalidParamRequestResponse(c, err.Error())
		return
	}

	resp := new(workflow.NodePanelSearchResponse)

	c.JSON(consts.StatusOK, resp)
}

// GetLLMNodeFCSettingsMerged .
// @router /api/workflow_api/llm_fc_setting_merged [POST]
func GetLLMNodeFCSettingsMerged(ctx context.Context, c *app.RequestContext) {
	var err error
	var req workflow.GetLLMNodeFCSettingsMergedRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		invalidParamRequestResponse(c, err.Error())
		return
	}

	resp, err := appworkflow.SVC.GetLLMNodeFCSettingsMerged(ctx, &req)
	if err != nil {
		internalServerErrorResponse(ctx, c, err)
		return
	}

	c.JSON(consts.StatusOK, resp)
}

// GetLLMNodeFCSettingDetail .
// @router /api/workflow_api/llm_fc_setting_detail [POST]
func GetLLMNodeFCSettingDetail(ctx context.Context, c *app.RequestContext) {
	var err error
	var req workflow.GetLLMNodeFCSettingDetailRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		invalidParamRequestResponse(c, err.Error())
		return
	}

	resp, err := appworkflow.SVC.GetLLMNodeFCSettingDetail(ctx, &req)
	if err != nil {
		internalServerErrorResponse(ctx, c, err)
		return
	}

	c.JSON(consts.StatusOK, resp)
}

// WorkFlowTestRun .
// @router /api/workflow_api/test_run [POST]
func WorkFlowTestRun(ctx context.Context, c *app.RequestContext) {
	var err error
	var req workflow.WorkFlowTestRunRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		invalidParamRequestResponse(c, err.Error())
		return
	}

	resp, err := appworkflow.SVC.TestRun(ctx, &req)
	if err != nil {
		internalServerErrorResponse(ctx, c, err)
		return
	}

	c.JSON(consts.StatusOK, resp)
}

// WorkFlowTestResume .
// @router /api/workflow_api/test_resume [POST]
func WorkFlowTestResume(ctx context.Context, c *app.RequestContext) {
	var err error
	var req workflow.WorkflowTestResumeRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		invalidParamRequestResponse(c, err.Error())
		return
	}

	resp, err := appworkflow.SVC.TestResume(ctx, &req)
	if err != nil {
		internalServerErrorResponse(ctx, c, err)
		return
	}

	c.JSON(consts.StatusOK, resp)
}

// CancelWorkFlow .
// @router /api/workflow_api/cancel [POST]
func CancelWorkFlow(ctx context.Context, c *app.RequestContext) {
	var err error
	var req workflow.CancelWorkFlowRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		invalidParamRequestResponse(c, err.Error())
		return
	}

	resp, err := appworkflow.SVC.Cancel(ctx, &req)
	if err != nil {
		internalServerErrorResponse(ctx, c, err)
		return
	}

	c.JSON(consts.StatusOK, resp)
}

// GetWorkFlowProcess .
// @router /api/workflow_api/get_process [GET]
func GetWorkFlowProcess(ctx context.Context, c *app.RequestContext) {
	var err error
	var req workflow.GetWorkflowProcessRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		invalidParamRequestResponse(c, err.Error())
		return
	}

	resp, err := appworkflow.SVC.GetProcess(ctx, &req)
	if err != nil {
		internalServerErrorResponse(ctx, c, err)
		return
	}

	c.JSON(consts.StatusOK, resp)
}

// GetNodeExecuteHistory .
// @router /api/workflow_api/get_node_execute_history [GET]
func GetNodeExecuteHistory(ctx context.Context, c *app.RequestContext) {
	var err error
	var req workflow.GetNodeExecuteHistoryRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		invalidParamRequestResponse(c, err.Error())
		return
	}

	resp, err := appworkflow.SVC.GetNodeExecuteHistory(ctx, &req)
	if err != nil {
		internalServerErrorResponse(ctx, c, err)
		return
	}

	c.JSON(consts.StatusOK, resp)
}

// GetApiDetail .
// @router /api/workflow_api/apiDetail [GET]
func GetApiDetail(ctx context.Context, c *app.RequestContext) {
	var err error
	var req workflow.GetApiDetailRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		invalidParamRequestResponse(c, err.Error())
		return
	}

	toolDetailInfo, err := appworkflow.SVC.GetApiDetail(ctx, &req)
	if err != nil {
		internalServerErrorResponse(ctx, c, err)
		return
	}

	response := map[string]interface{}{
		"data": toolDetailInfo,
		"code": 0,
		"msg":  "",
	}

	c.JSON(consts.StatusOK, response)
}

// WorkflowNodeDebugV2 .
// @router /api/workflow_api/nodeDebug [POST]
func WorkflowNodeDebugV2(ctx context.Context, c *app.RequestContext) {
	var err error
	var req workflow.WorkflowNodeDebugV2Request
	err = c.BindAndValidate(&req)
	if err != nil {
		invalidParamRequestResponse(c, err.Error())
		return
	}

	resp, err := appworkflow.SVC.NodeDebug(ctx, &req)
	if err != nil {
		internalServerErrorResponse(ctx, c, err)
		return
	}

	c.JSON(consts.StatusOK, resp)
}

// SignImageURL .
// @router /api/workflow_api/sign_image_url [POST]
func SignImageURL(ctx context.Context, c *app.RequestContext) {
	var err error
	var req workflow.SignImageURLRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		invalidParamRequestResponse(c, err.Error())
		return
	}

	resp, err := appworkflow.SVC.SignImageURL(ctx, &req)
	if err != nil {
		internalServerErrorResponse(ctx, c, err)
		return
	}

	c.JSON(consts.StatusOK, resp)
}

// CreateProjectConversationDef .
// @router /api/workflow_api/project_conversation/create [POST]
func CreateProjectConversationDef(ctx context.Context, c *app.RequestContext) {
	var err error
	var req workflow.CreateProjectConversationDefRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		invalidParamRequestResponse(c, err.Error())
		return
	}

	resp := new(workflow.CreateProjectConversationDefResponse)

	c.JSON(consts.StatusOK, resp)
}

// UpdateProjectConversationDef .
// @router /api/workflow_api/project_conversation/update [POST]
func UpdateProjectConversationDef(ctx context.Context, c *app.RequestContext) {
	var err error
	var req workflow.UpdateProjectConversationDefRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		invalidParamRequestResponse(c, err.Error())
		return
	}

	resp := new(workflow.UpdateProjectConversationDefResponse)

	c.JSON(consts.StatusOK, resp)
}

// DeleteProjectConversationDef .
// @router /api/workflow_api/project_conversation/delete [POST]
func DeleteProjectConversationDef(ctx context.Context, c *app.RequestContext) {
	var err error
	var req workflow.DeleteProjectConversationDefRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		invalidParamRequestResponse(c, err.Error())
		return
	}

	resp := new(workflow.DeleteProjectConversationDefResponse)

	c.JSON(consts.StatusOK, resp)
}

// ListProjectConversationDef .
// @router /api/workflow_api/project_conversation/list [GET]
func ListProjectConversationDef(ctx context.Context, c *app.RequestContext) {
	var err error
	var req workflow.ListProjectConversationRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		invalidParamRequestResponse(c, err.Error())
		return
	}

	resp := new(workflow.ListProjectConversationResponse)

	c.JSON(consts.StatusOK, resp)
}

// ListRootSpans .
// @router /api/workflow_api/list_spans [POST]
func ListRootSpans(ctx context.Context, c *app.RequestContext) {
	var err error
	var req workflow.ListRootSpansRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		invalidParamRequestResponse(c, err.Error())
		return
	}

	resp := new(workflow.ListRootSpansResponse)

	c.JSON(consts.StatusOK, resp)
}

// GetTraceSDK .
// @router /api/workflow_api/get_trace [POST]
func GetTraceSDK(ctx context.Context, c *app.RequestContext) {
	var err error
	var req workflow.GetTraceSDKRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		invalidParamRequestResponse(c, err.Error())
		return
	}

	resp := new(workflow.GetTraceSDKResponse)

	c.JSON(consts.StatusOK, resp)
}

// GetWorkflowDetail .
// @router /api/workflow_api/workflow_detail [POST]
func GetWorkflowDetail(ctx context.Context, c *app.RequestContext) {
	var err error
	var req workflow.GetWorkflowDetailRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		invalidParamRequestResponse(c, err.Error())
		return
	}

	workflowDetailDataList, err := appworkflow.SVC.GetWorkflowDetail(ctx, &req)
	if err != nil {
		internalServerErrorResponse(ctx, c, err)
		return
	}

	response := map[string]any{
		"data":    workflowDetailDataList,
		"code":    0,
		"message": "",
	}

	c.JSON(consts.StatusOK, response)
}

// GetWorkflowDetailInfo .
// @router /api/workflow_api/workflow_detail_info [POST]
func GetWorkflowDetailInfo(ctx context.Context, c *app.RequestContext) {
	var err error
	var req workflow.GetWorkflowDetailInfoRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		invalidParamRequestResponse(c, err.Error())
		return
	}

	workflowDetailInfoDataList, err := appworkflow.SVC.GetWorkflowDetailInfo(ctx, &req)
	if err != nil {
		internalServerErrorResponse(ctx, c, err)
		return
	}

	response := map[string]any{
		"data":    workflowDetailInfoDataList,
		"code":    0,
		"message": "",
	}

	c.JSON(consts.StatusOK, response)
}

// ValidateTree . TODO 验证工作流是否正常
// @router /api/workflow_api/validate_tree [POST]
func ValidateTree(ctx context.Context, c *app.RequestContext) {
	var err error
	var req workflow.ValidateTreeRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		invalidParamRequestResponse(c, err.Error())
		return
	}

	resp, err := appworkflow.SVC.ValidateTree(ctx, &req)
	if err != nil {
		internalServerErrorResponse(ctx, c, err)
		return
	}

	c.JSON(consts.StatusOK, resp)
}

// GetChatFlowRole .
// @router /api/workflow_api/chat_flow_role/get [GET]
func GetChatFlowRole(ctx context.Context, c *app.RequestContext) {
	var err error
	var req workflow.GetChatFlowRoleRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		invalidParamRequestResponse(c, err.Error())
		return
	}

	resp := new(workflow.GetChatFlowRoleResponse)

	c.JSON(consts.StatusOK, resp)
}

// CreateChatFlowRole .
// @router /api/workflow_api/chat_flow_role/create [POST]
func CreateChatFlowRole(ctx context.Context, c *app.RequestContext) {
	var err error
	var req workflow.CreateChatFlowRoleRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		invalidParamRequestResponse(c, err.Error())
		return
	}

	resp := new(workflow.CreateChatFlowRoleResponse)

	c.JSON(consts.StatusOK, resp)
}

// DeleteChatFlowRole .
// @router /api/workflow_api/chat_flow_role/delete [POST]
func DeleteChatFlowRole(ctx context.Context, c *app.RequestContext) {
	var err error
	var req workflow.DeleteChatFlowRoleRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		invalidParamRequestResponse(c, err.Error())
		return
	}

	resp := new(workflow.DeleteChatFlowRoleResponse)

	c.JSON(consts.StatusOK, resp)
}

// ListPublishWorkflow .
// @router /api/workflow_api/list_publish_workflow [POST]
func ListPublishWorkflow(ctx context.Context, c *app.RequestContext) {
	var err error
	var req workflow.ListPublishWorkflowRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		invalidParamRequestResponse(c, err.Error())
		return
	}

	resp := new(workflow.ListPublishWorkflowResponse)

	c.JSON(consts.StatusOK, resp)
}

// GetWorkflowUploadAuthToken .
// @router /api/workflow_api/upload/auth_token [POST]
func GetWorkflowUploadAuthToken(ctx context.Context, c *app.RequestContext) {
	var err error
	var req workflow.GetUploadAuthTokenRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		invalidParamRequestResponse(c, err.Error())
		return
	}

	resp, err := appworkflow.SVC.GetWorkflowUploadAuthToken(ctx, &req)
	if err != nil {
		internalServerErrorResponse(ctx, c, err)
		return
	}

	c.JSON(consts.StatusOK, resp)
}

func preprocessWorkflowRequestBody(_ context.Context, c *app.RequestContext) error {
	// Read the raw request body
	rawData, err := c.Request.BodyE()
	if err != nil {
		return fmt.Errorf("failed to read request body: %w", err)
	}

	// Unmarshal into a temporary map
	var bodyData map[string]interface{}
	if err = sonic.Unmarshal(rawData, &bodyData); err != nil {
		return fmt.Errorf("failed to unmarshal request body: %w", err)
	}

	// Process 'parameters' field
	if parameters, ok := bodyData["parameters"]; ok {
		if _, isString := parameters.(string); !isString {
			// It's not a string, needs modification.
			paramsBytes, marshalErr := sonic.Marshal(parameters)
			if marshalErr != nil {
				return fmt.Errorf("failed to marshal parameters: %w", marshalErr)
			}
			bodyData["parameters"] = string(paramsBytes)

			newRawData, err := sonic.Marshal(bodyData)
			if err != nil {
				return fmt.Errorf("failed to marshal modified body: %w", err)
			}
			c.Request.SetBodyRaw(newRawData)
			return nil
		}
	}

	return nil
}

// OpenAPIRunFlow 执行工作流运行接口
// 该函数处理工作流的同步执行请求，类似于 Spring Boot 中 @PostMapping 注解的 Controller 方法
//
// 功能说明：
//   - 接收工作流运行请求并进行参数验证
//   - 调用应用层服务执行工作流
//   - 处理执行结果并返回响应
//   - 支持错误处理和调试信息返回
//
// 参数：
//   - ctx: 请求上下文，用于传递请求级别的信息和超时控制
//   - c: HTTP 请求上下文，包含请求和响应信息
//
// 返回：
//   - 无返回值，直接通过 c.JSON 返回 HTTP 响应
//
// @router /v1/workflow/run [POST]
func OpenAPIRunFlow(ctx context.Context, c *app.RequestContext) {
	var err error

	// 步骤1: 预处理请求体，进行基础校验和格式化
	if err = preprocessWorkflowRequestBody(ctx, c); err != nil {
		invalidParamRequestResponse(c, err.Error())
		return
	}

	// 步骤2: 绑定并验证请求参数到结构体
	var req workflow.OpenAPIRunFlowRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		invalidParamRequestResponse(c, err.Error())
		return
	}

	// 步骤3: 调用应用层服务执行工作流
	resp, err := appworkflow.SVC.OpenAPIRun(ctx, &req)
	if err != nil {
		// 步骤4: 处理业务错误，将工作流特定错误转换为标准响应格式
		var se vo.WorkflowError
		if errors.As(err, &se) {
			resp = new(workflow.OpenAPIRunFlowResponse)
			resp.Code = int64(se.OpenAPICode())
			resp.Msg = ptr.Of(se.Msg())
			debugURL := se.DebugURL()
			if debugURL != "" {
				resp.DebugUrl = ptr.Of(debugURL)
			}
			c.JSON(consts.StatusOK, resp)
			return
		}

		// 步骤5: 处理系统级错误
		internalServerErrorResponse(ctx, c, err)
		return
	}

	// 步骤6: 返回成功响应
	c.JSON(consts.StatusOK, resp)
}

// streamRunData 流式运行数据结构
// 用于封装工作流流式执行过程中的响应数据，类似于 Spring Boot 中的 DTO (Data Transfer Object)
type streamRunData struct {
	Content       *string        `json:"content,omitempty"`        // 节点输出内容
	ContentType   *string        `json:"content_type,omitempty"`   // 内容类型
	NodeSeqID     *string        `json:"node_seq_id,omitempty"`    // 节点序列ID
	NodeID        *string        `json:"node_id,omitempty"`        // 节点唯一标识
	NodeIsFinish  *bool          `json:"node_is_finish,omitempty"` // 节点是否执行完成
	NodeType      *string        `json:"node_type,omitempty"`      // 节点类型
	NodeTitle     *string        `json:"node_title,omitempty"`     // 节点标题
	Token         *int64         `json:"token,omitempty"`          // 消耗的 token 数量
	DebugURL      *string        `json:"debug_url,omitempty"`      // 调试链接
	ErrorCode     *int64         `json:"error_code,omitempty"`     // 错误代码
	ErrorMessage  *string        `json:"error_message,omitempty"`  // 错误消息
	InterruptData *interruptData `json:"interrupt_data,omitempty"` // 中断数据
}

// interruptData 中断数据结构
// 用于处理工作流执行过程中的中断事件信息
type interruptData struct {
	EventID string `json:"event_id"` // 事件唯一标识
	Type    int64  `json:"type"`     // 中断类型
	Data    string `json:"data"`     // 中断相关数据
}

// convertStreamRunData 转换流式运行数据
// 将应用层的流式响应数据转换为 API 层的响应格式
// 类似于 Spring Boot 中的 Converter 或 Mapper，用于不同层之间的数据转换
//
// 参数：
//   - msg: 应用层的流式运行响应数据
//
// 返回：
//   - *streamRunData: 转换后的 API 响应数据结构
func convertStreamRunData(msg *workflow.OpenAPIStreamRunFlowResponse) *streamRunData {
	// 处理中断数据的转换
	var ie *interruptData
	if msg.InterruptData != nil {
		ie = &interruptData{
			EventID: msg.InterruptData.EventID,
			Type:    int64(msg.InterruptData.Type),
			Data:    msg.InterruptData.InData,
		}
	}

	// 构建并返回转换后的数据结构
	return &streamRunData{
		Content:       msg.Content,
		ContentType:   msg.ContentType,
		NodeSeqID:     msg.NodeSeqID,
		NodeID:        msg.NodeID,
		NodeIsFinish:  msg.NodeIsFinish,
		NodeType:      msg.NodeType,
		NodeTitle:     msg.NodeTitle,
		Token:         msg.Token,
		DebugURL:      msg.DebugUrl,
		ErrorCode:     msg.ErrorCode,
		ErrorMessage:  msg.ErrorMessage,
		InterruptData: ie,
	}
}

// sendStreamRunSSE 发送流式运行 SSE 事件
// 处理工作流流式执行过程中的 Server-Sent Events 推送
// 类似于 Spring Boot 中使用 SseEmitter 进行实时数据推送的功能
//
// 功能说明：
//   - 持续读取流式数据并转换为 SSE 事件格式
//   - 处理数据序列化和错误处理
//   - 确保资源正确释放
//
// 参数：
//   - ctx: 请求上下文，用于日志记录和超时控制
//   - w: SSE 写入器，用于向客户端发送事件
//   - sr: 流式数据读取器，从应用层获取实时数据
func sendStreamRunSSE(ctx context.Context, w *sse.Writer, sr *schema.StreamReader[*workflow.OpenAPIStreamRunFlowResponse]) {
	// 确保资源正确释放
	defer func() {
		_ = w.Close()
		sr.Close()
	}()

	// 持续读取并推送流式数据
	for {
		// 步骤1: 从流中接收消息
		msg, err := sr.Recv()
		if err != nil {
			if errors.Is(err, io.EOF) {
				// 步骤2: 正常结束，跳出循环
				break
			}

			// 步骤3: 处理接收错误，发送错误事件
			event := &sse.Event{
				Type: "error",
				Data: []byte(err.Error()),
			}

			if err = w.Write(event); err != nil {
				logs.CtxErrorf(ctx, "publish stream event failed, err:%v", err)
			}
			return
		}

		// 步骤4: 转换数据格式
		converted := convertStreamRunData(msg)
		msgBytes, err := sonic.Marshal(converted)
		if err != nil {
			// 步骤5: 处理序列化错误
			event := &sse.Event{
				Type: "error",
				Data: []byte(err.Error()),
			}
			if err = w.Write(event); err != nil {
				logs.CtxErrorf(ctx, "publish stream event failed, err:%v", err)
			}
			return
		}

		// 步骤6: 构建并发送 SSE 事件
		event := &sse.Event{
			ID:   msg.ID,
			Type: msg.Event,
			Data: msgBytes,
		}

		if err = w.Write(event); err != nil {
			logs.CtxErrorf(ctx, "publish stream event failed, err:%v", err)
			return
		}
	}
}

// OpenAPIStreamRunFlow 执行工作流流式运行接口
// 该函数处理工作流的流式执行请求，支持实时数据推送
// 类似于 Spring Boot 中使用 SseEmitter 的流式响应接口
//
// 功能说明：
//   - 接收工作流流式运行请求并进行参数验证
//   - 配置 SSE (Server-Sent Events) 响应头
//   - 调用应用层服务启动流式执行
//   - 通过 SSE 实时推送执行过程和结果
//
// 参数：
//   - ctx: 请求上下文，用于传递请求级别的信息和超时控制
//   - c: HTTP 请求上下文，包含请求和响应信息
//
// 返回：
//   - 无返回值，通过 SSE 流式返回数据
//
// @router /v1/workflow/stream_run [POST]
func OpenAPIStreamRunFlow(ctx context.Context, c *app.RequestContext) {
	var err error

	// 步骤1: 预处理请求体，进行基础校验和格式化
	if err = preprocessWorkflowRequestBody(ctx, c); err != nil {
		invalidParamRequestResponse(c, err.Error())
		return
	}

	// 步骤2: 绑定并验证请求参数到结构体
	var req workflow.OpenAPIRunFlowRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		invalidParamRequestResponse(c, err.Error())
		return
	}

	// 步骤3: 创建 SSE 写入器
	w := sse.NewWriter(c)

	// 步骤4: 设置 SSE 响应头，配置流式传输
	c.SetContentType("text/event-stream; charset=utf-8")
	c.Response.Header.Set("Cache-Control", "no-cache")
	c.Response.Header.Set("Connection", "keep-alive")
	c.Response.Header.Set("Access-Control-Allow-Origin", "*")

	// 步骤5: 调用应用层服务启动流式执行
	sr, err := appworkflow.SVC.OpenAPIStreamRun(ctx, &req)
	if err != nil {
		internalServerErrorResponse(ctx, c, err)
		return
	}

	// 步骤6: 开始 SSE 数据推送
	sendStreamRunSSE(ctx, w, sr)
}

// OpenAPIStreamResumeFlow 恢复工作流流式执行接口
// 该函数处理工作流中断后的恢复执行请求，支持实时数据推送
// 类似于 Spring Boot 中的断点续传或任务恢复功能
//
// 功能说明：
//   - 接收工作流恢复执行请求并进行参数验证
//   - 配置 SSE 响应头用于流式数据传输
//   - 调用应用层服务恢复工作流执行
//   - 通过 SSE 实时推送恢复执行的过程和结果
//
// 参数：
//   - ctx: 请求上下文，用于传递请求级别的信息和超时控制
//   - c: HTTP 请求上下文，包含请求和响应信息
//
// 返回：
//   - 无返回值，通过 SSE 流式返回数据
//
// @router /v1/workflow/stream_resume [POST]
func OpenAPIStreamResumeFlow(ctx context.Context, c *app.RequestContext) {
	var err error

	// 步骤1: 绑定并验证恢复请求参数
	var req workflow.OpenAPIStreamResumeFlowRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		invalidParamRequestResponse(c, err.Error())
		return
	}

	// 步骤2: 创建 SSE 写入器
	w := sse.NewWriter(c)

	// 步骤3: 设置 SSE 响应头，配置流式传输
	c.SetContentType("text/event-stream; charset=utf-8")
	c.Response.Header.Set("Cache-Control", "no-cache")
	c.Response.Header.Set("Connection", "keep-alive")
	c.Response.Header.Set("Access-Control-Allow-Origin", "*")

	// 步骤4: 调用应用层服务恢复流式执行
	sr, err := appworkflow.SVC.OpenAPIStreamResume(ctx, &req)
	if err != nil {
		internalServerErrorResponse(ctx, c, err)
		return
	}

	// 步骤5: 开始 SSE 数据推送
	sendStreamRunSSE(ctx, w, sr)
}

// OpenAPIGetWorkflowRunHistory 获取工作流运行历史接口
// 该函数处理获取工作流执行历史记录的请求
// 类似于 Spring Boot 中的查询接口，用于获取历史数据
//
// 功能说明：
//   - 接收查询工作流运行历史的请求并进行参数验证
//   - 调用应用层服务获取历史记录
//   - 处理业务错误和系统错误
//   - 返回格式化的历史记录响应
//
// 参数：
//   - ctx: 请求上下文，用于传递请求级别的信息和超时控制
//   - c: HTTP 请求上下文，包含请求和响应信息
//
// 返回：
//   - 无返回值，直接通过 c.JSON 返回 HTTP 响应
//
// @router /v1/workflow/get_run_history [GET]
func OpenAPIGetWorkflowRunHistory(ctx context.Context, c *app.RequestContext) {
	var err error

	// 步骤1: 绑定并验证查询请求参数
	var req workflow.GetWorkflowRunHistoryRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		invalidParamRequestResponse(c, err.Error())
		return
	}

	// 步骤2: 调用应用层服务获取运行历史
	resp, err := appworkflow.SVC.OpenAPIGetWorkflowRunHistory(ctx, &req)
	if err != nil {
		// 步骤3: 处理业务错误，将工作流特定错误转换为标准响应格式
		var se vo.WorkflowError
		if errors.As(err, &se) {
			resp = new(workflow.GetWorkflowRunHistoryResponse)
			resp.Code = ptr.Of(int64(se.OpenAPICode()))
			resp.Msg = ptr.Of(se.Msg())
			c.JSON(consts.StatusOK, resp)
			return
		}

		// 步骤4: 处理系统级错误
		internalServerErrorResponse(ctx, c, err)
		return
	}

	// 步骤5: 返回成功响应
	c.JSON(consts.StatusOK, resp)
}

// OpenAPIChatFlowRun 聊天工作流运行接口
// 该函数处理聊天式工作流的执行请求，提供对话式的工作流交互
// 类似于 Spring Boot 中的聊天机器人或对话系统接口
//
// 功能说明：
//   - 接收聊天工作流运行请求并进行参数验证
//   - 处理对话式的工作流交互逻辑
//   - 返回聊天响应结果
//
// 参数：
//   - ctx: 请求上下文，用于传递请求级别的信息和超时控制
//   - c: HTTP 请求上下文，包含请求和响应信息
//
// 返回：
//   - 无返回值，直接通过 c.JSON 返回 HTTP 响应
//
// 注意：当前实现为占位符，实际业务逻辑待完善
//
// @router /v1/workflows/chat [POST]
func OpenAPIChatFlowRun(ctx context.Context, c *app.RequestContext) {
	var err error

	// 步骤1: 绑定并验证聊天请求参数
	var req workflow.ChatFlowRunRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		invalidParamRequestResponse(c, err.Error())
		return
	}

	// 步骤2: 创建响应对象（当前为空实现，待后续完善业务逻辑）
	resp := new(workflow.ChatFlowRunResponse)

	// 步骤3: 返回响应（当前直接返回空响应）
	c.JSON(consts.StatusOK, resp)
}

// OpenAPIGetWorkflowInfo 获取工作流信息接口
// 该函数处理获取指定工作流详细信息的请求
// 类似于 Spring Boot 中的 @GetMapping("/{id}") 查询单个资源的接口
//
// 功能说明：
//   - 接收工作流ID参数并进行验证
//   - 查询并返回指定工作流的详细信息
//   - 支持RESTful风格的路径参数
//
// 参数：
//   - ctx: 请求上下文，用于传递请求级别的信息和超时控制
//   - c: HTTP 请求上下文，包含请求和响应信息
//
// 返回：
//   - 无返回值，直接通过 c.JSON 返回 HTTP 响应
//
// 注意：当前实现为占位符，实际业务逻辑待完善
//
// @router /v1/workflows/:workflow_id [GET]
func OpenAPIGetWorkflowInfo(ctx context.Context, c *app.RequestContext) {
	var err error

	// 步骤1: 绑定并验证路径参数（工作流ID）
	var req workflow.OpenAPIGetWorkflowInfoRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		invalidParamRequestResponse(c, err.Error())
		return
	}

	// 步骤2: 创建响应对象（当前为空实现，待后续完善业务逻辑）
	resp := new(workflow.OpenAPIGetWorkflowInfoResponse)

	// 步骤3: 返回响应（当前直接返回空响应）
	c.JSON(consts.StatusOK, resp)
}

// GetHistorySchema 获取历史记录模式接口
// 该函数处理获取工作流历史记录数据结构模式的请求
// 类似于 Spring Boot 中获取数据模型或元数据信息的接口
//
// 功能说明：
//   - 接收历史记录模式查询请求并进行参数验证
//   - 调用应用层服务获取历史记录的数据结构模式
//   - 返回模式定义，用于前端动态渲染或数据处理
//
// 参数：
//   - ctx: 请求上下文，用于传递请求级别的信息和超时控制
//   - c: HTTP 请求上下文，包含请求和响应信息
//
// 返回：
//   - 无返回值，直接通过 c.JSON 返回 HTTP 响应
//
// @router /api/workflow_api/history_schema [POST]
func GetHistorySchema(ctx context.Context, c *app.RequestContext) {
	var err error

	// 步骤1: 绑定并验证请求参数
	var req workflow.GetHistorySchemaRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		invalidParamRequestResponse(c, err.Error())
		return
	}

	// 步骤2: 调用应用层服务获取历史记录模式
	resp, err := appworkflow.SVC.GetHistorySchema(ctx, &req)
	if err != nil {
		// 步骤3: 处理系统级错误
		internalServerErrorResponse(ctx, c, err)
		return
	}

	// 步骤4: 返回成功响应
	c.JSON(consts.StatusOK, resp)
}

// GetExampleWorkFlowList 获取示例工作流列表接口
// 该函数处理获取示例工作流列表的请求，用于为用户提供工作流模板
// 类似于 Spring Boot 中的模板或示例数据查询接口
//
// 功能说明：
//   - 接收示例工作流列表查询请求并进行参数验证
//   - 调用应用层服务获取预定义的示例工作流
//   - 返回示例工作流列表，供用户参考和使用
//
// 参数：
//   - ctx: 请求上下文，用于传递请求级别的信息和超时控制
//   - c: HTTP 请求上下文，包含请求和响应信息
//
// 返回：
//   - 无返回值，直接通过 c.JSON 返回 HTTP 响应
//
// @router /api/workflow_api/example_workflow_list [POST]
func GetExampleWorkFlowList(ctx context.Context, c *app.RequestContext) {
	var err error

	// 步骤1: 绑定并验证请求参数
	var req workflow.GetExampleWorkFlowListRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		invalidParamRequestResponse(c, err.Error())
		return
	}

	// 步骤2: 调用应用层服务获取示例工作流列表
	resp, err := appworkflow.SVC.GetExampleWorkFlowList(ctx, &req)
	if err != nil {
		// 步骤3: 处理系统级错误
		internalServerErrorResponse(ctx, c, err)
		return
	}

	// 步骤4: 返回成功响应
	c.JSON(consts.StatusOK, resp)
}
